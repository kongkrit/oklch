<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="icon" href="oklch.svg" type="image/svg+xml">     
<title>okLCH ↔ sRGB Tool with Load/Save</title>
<style>
  :root {
    /* --- display and calculation precision, # of digits after decimal point --- */
	--L-precision: 5;
	--C-precision: 5;
	--H-precision: 3;
	--deltaE-precision: 5;
  }
  :root { /* size controls besides border */
    --max-width: 1200px;
    --gap: 10px;
    --pad: 12px;
	
	--fs-h1: 22px;
	--margin-h1: 6px 0 10px;
	
	--fs-controls: 14px/1.2;
	--gap-controls: 12px;
	--margin-right-controls-label: 10px;
	
	--fs-button: 14px;
	--padding-button: 6px 10px;
	--border-radius-button: 8px;
	
	--fs-oklch-info: 14px/1.5;
	--margin-top-oklch-info: 6px;
	--min-height-oklch-info: 1.3em;  /* reserve one line even when empty */
	
	--padding-controls-fieldset: 6px 10px;
	--border-radius-controls-fieldset: 8px;
	
	--fs-legend: 14px/1.4;
	--margin-bottom-legend: 4px;
	
	--fs-rows-text: 16px;    /* iOS: ≥16px prevents focus-zoom and sizing drift */
    --row: 34px;             /* keep row height aligned with fs */
    --fs-convert-button: 14px;
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
	
	--patches-column-width: 160px;
	
	--convert-button-border-radius: 6px;
	--convert-button-line-height-subtraction: 2px;
	
	--col-button-padding: 4px 0px;
    --col-border-radius: 8px;
	--col-padding: 4px 6px;
	
	--legend-directchild-padding: 0 6px;
	
	--fs-note: 12px;
	--opacity-note: 0.8;
	--margin-top-note: 10px;
	--gap-note: 8px;
  }
  :root {
    /* derive existing tokens from the palette */
    --border: 1px solid var(--color-border);
    --line: var(--color-line);
    --ph: var(--color-placeholder);
    --error: var(--color-error);
    --error-bg: var(--color-error-bg);
    --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: var(--color-bg);
    color: var(--color-fg);
  }
  header, main {
    max-width: var(--max-width);
    margin: 0 auto;
    padding: var(--pad);
  }
  h1 { font-size: var(--fs-h1); margin: var(--margin-h1); }
  .controls { font: var(--fs-controls) var(--font); display: flex; gap: var(--gap-controls); align-items: center; flex-wrap: wrap; }
  .controls fieldset { border: var(--border); border-radius: var(--border-radius-controls-fieldset); padding: var(--padding-controls-fieldset); background: var(--color-surface); }
  .controls label { margin-right: var(--margin-right-controls-label); }

  /* Grid wrapper defines the column tracks */
  .gridwrap {
    display: grid;
    /* Ensure `ch` resolves from this monospace context */
  --oklch-col-width: calc((13 + var(--L-precision) + var(--C-precision) + var(--H-precision)) * 1ch);
  --deltaE-col-width: calc((3.5 + var(--deltaE-precision)) * 1ch);
  --cols: 8ch 5ch var(--patches-column-width) 5ch var(--oklch-col-width) 5ch 8ch var(--deltaE-col-width) 40ch;
  grid-template-columns: var(--cols);
    gap: var(--gap);
    align-items: start;
    /* Ensure `ch` is measured from the same monospace and size as row content */
    font-family: var(--font);
    font-size: var(--fs-rows-text);
    line-height: var(--row);
  }

  /* Legend (header) consumes the parent's tracks via subgrid */
  .legend {
    display: grid;
    grid-template-columns: subgrid;
    grid-column: 1 / -1;
    gap: var(--gap);
    margin-bottom: var(--margin-bottom-legend);
    font: var(--fs-legend) var(--font);
    opacity: .7;
  }
  /* match inner padding of .col so text aligns */
  .legend > div { padding: var(--legend-directchild-padding); }

  /* Data grid also consumes the parent's tracks via subgrid */
  .app {
    display: grid;
    grid-template-columns: subgrid;
    grid-column: 1 / -1;
    gap: var(--gap);
    align-items: start;
  }

  .col-button {
    position: relative;
    display: grid;
    grid-auto-rows: var(--row);
    border: none;
    padding: var(--col-button-padding);
    gap: 0;
  }
  .col {
    position: relative;
    display: grid;
    grid-auto-rows: var(--row);
    border: var(--border);
    border-radius: var(--col-border-radius);
    background:
      linear-gradient(to bottom, var(--line), var(--line) 1px, transparent 1px var(--row)) content-box,
      var(--color-surface);
    background-size: 100% var(--row), auto;
    background-repeat: repeat-y, no-repeat;
    background-origin: content-box, border-box;
    padding: var(--col-padding);
    gap: 0;
  }

  /* Row elements */
  .chip { width: 100%; height: var(--row); }
  .rowtext, .rowinput, .convert-button {
    font-family: var(--font);
    line-height: var(--row);
    height: var(--row);
    font-variant-ligatures: none;
    font-kerning: none;
    letter-spacing: 0;
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
  }
  .rowtext, .rowinput { font-size: var(--fs-rows-text); }
  .convert-button { font-size: var(--fs-convert-button); }
  .rowinput {
  	color: inherit;
    border: none;
    outline: none;
    width: 100%;
    background: transparent;
    padding: 0;
    margin: 0;
  }
  .rowinput::placeholder { color: var(--ph); opacity: 1; }
  .rowinput::-webkit-input-placeholder { color: var(--ph); opacity: 1; }
  .note { font-size: var(--fs-note); opacity: var(--opacity-note); margin-top: var(--margin-top-note); display: flex; gap: var(--gap-note); flex-wrap: wrap; align-items: center;}

  button {
    font-family: var(--font);
    font-size: inherit;
    font: var(--fs-button) var(--font);
    padding: var(--padding-button);
    border: var(--border);
    border-radius: var(--border-radius-button);
    background: var(--color-surface);
    cursor: pointer;
	color: var(--color-fg);              /* force text color */
    -webkit-appearance: none;            /* drop native tinting */
    appearance: none;
  }
  button, input {
    font-variant-ligatures: none;
    font-kerning: none;
    letter-spacing: 0;
  }
  button:hover { background: var(--color-surface-hover); }
  .oklch-info {
    margin-top: var(--margin-top-oklch-info);
    font: var(--fs-oklch-info) var(--font);
    color:var(--color-fg);
    min-height: var(--min-height-oklch-info);
  }
  .oklch-info.err {
  	color: var(--error);
    background:var(--error-bg);
    font-weight:700;
  }
  #oklch .rowinput.err{color:var(--error);font-weight:700;background:var(--error-bg);}

  /* Convert buttons (→LCH / ←HEX) */
  .convert-button {
  	color: inherit;
    font-family: var(--font);
    width: 5ch;                /* fixed as requested */
    height: var(--row);
    padding: 0;
    margin: 0 auto;            /* center within column */
    border: var(--border);
    border-radius: var(--convert-button-border-radius);
    background: var(--color-surface);
    display: block;
    line-height: calc(var(--row) - var(--convert-button-line-height-subtraction)); /* vertically center text */
    text-align: center;
    cursor: default;           /* not wired yet */
    user-select: none;
  }
  .convert-button:focus-visible {
    outline: 1px solid var(--color-outline);
    outline-offset: 1px;
  }
  
  #strips {
    background: var(--color-strips-bg);
  }

/* ============
   THEME TOKENS
   ============ */
/* Light theme (explicit) */
:root[data-theme="light"] {
  /* original light palette */
  --color-bg: #f7f8fa;
  --color-fg: #1b1f23;
  --color-surface: #ffffff;
  --color-surface-hover: #f2f3f5;
  --color-strips-bg: #ffffff;
  --color-border: rgba(0,0,0,.12);
  --color-line: rgba(0,0,0,.08);
  --color-placeholder: rgba(0,0,0,.45);
  --color-error: #b00020;
  --color-error-bg: #fff8c4;
  --color-black: #000;
  --color-white: #fff;
  --color-outline: color-mix(in oklab, var(--color-black), var(--color-white) 50%);

  /* form-control tokens to keep radios readable in light theme */
  --color-control-bg: var(--color-surface);
  --color-control-bg-checked: #1b1f23;     /* visible dot */
  --color-control-border: var(--color-border);
  --color-control-dot: #fff;               /* dot on dark checked bg */
}

/* Dark theme */
:root[data-theme="dark"] {
  --color-bg: #0f1115;
  --color-fg: #cecece;
  --color-surface: #161a20;
  --color-surface-hover: #1c222b;
  --color-strips-bg: #000000;
  --color-border: rgba(255,255,255,.16);
  --color-line: rgba(255,255,255,.10);
  --color-placeholder: rgba(255,255,255,.45);
  --color-error: #ff4d57;
  --color-error-bg: #2a1900;
  --color-black: #000;
  --color-white: #ffffff;
  --color-outline: color-mix(in oklab, var(--color-white), var(--color-black) 50%);

  /* form-control tokens for dark theme */
  --color-control-bg: #0f1115;
  --color-control-bg-checked: #e6e9ef;
  --color-control-border: rgba(255,255,255,.28);
  --color-control-dot: #0f1115;
}

/* Prefer UA theming per explicit theme */
html[data-theme="light"] { color-scheme: light; }
html[data-theme="dark"]  { color-scheme: dark;  }

</style>
</head>
<body>
<header>
  <h1>okLCH ↔ sRGB Tool with Load/Save</h1>
  <div class="controls">
    <fieldset>
      <legend>ΔE calculations</legend>
      <label><input type="radio" name="deSrc" value="col3" checked> #1 vs #3</label>
      <label><input type="radio" name="deSrc" value="col4"> #1 vs #4</label>
    </fieldset>
	<button id="theme">Theme</button>
    <button id="clear">Clear All</button>
    <button id="load">Load JSON</button>
    <button id="copy">Copy to Clipboard</button>
    <button id="save">Save JSON</button>
  </div>
  <div class="oklch-info" id="oklch-info" aria-live="polite"></div>
</header>

<main>
  <div class="gridwrap">
    <div class="legend">
      <div>#1 RGB Input</div>
      <div>→LCH</div>
      <div>#2 RGB / LCH</div>
      <div>←HEX</div>
      <div>#3 okLCH</div>
      <div>←LCH</div>
      <div>#4 LCH to RGB</div>
      <div>#5 ΔE</div>
      <div>Comments</div>
    </div>

    <div class="app">
      <div id="rgbcol" class="col"></div>
      <div id="rgbtolch" class="col-button"></div>   <!-- new button column: →LCH -->
      <div id="strips" class="col"></div>
      <div id="lchtorgb" class="col-button"></div>   <!-- new button column: ←HEX -->
      <div id="oklch" class="col"></div>
      <div id="lrgbtolch" class="col-button"></div>
      <div id="lrgb" class="col"></div>
      <div id="deltae" class="col"></div>
      <div id="comment" class="col"></div>
    </div>
  </div>

  <div class="note">
    This is supposed to be some text with fancy <code>code</code> snippet and <code>more: code</code> and even more <code>.leetcode</code>.
  </div>
</main>

<script>
(function(root){
  // ---- constants that affect look ----
  const ROWS = 32;
  const defaultValues = [
  { "rgb": "#12abef",
    "oklch_hex": ["0x3fe6771eba7c192f","0x3fc31a414d5eb105","0x406d91e406383b14"],
    "oklch": "0.70204 0.14924 236.559",
    "comment": "some random color"
  },
  { "rgb": "#ff0000",
    "comment": "red"
  },
  { "rgb": "#00ff00",
    "oklch_hex": ["0x3febb9df9070260c","0x3fd2de7312cdea2f","0x4061cfd9d0f07296"],
    "oklch": "0.86644 0.29482 142.495",
    "comment": "green"
  },
  { "rgb": "#0000ff",
    "comment": "blue"
  },
  { "rgb": "#777777",
    "oklch_hex": ["0x3fe23765c7ad6c6c","0x3e56c88c2a7d00ed","0x405678093a730d69"],
    "oklch": "0.56926 0.00000 89.876",
    "comment": "mid"
  },
  { "rgb": "#abcdef",
    "oklch_hex": ["0x3feab825a3323e4b","0x3faecc6e00c85a18","0x406f119cb6020b21"],
    "oklch": "0.83498 0.06015 248.550"
  },
  { "rgb": "#c0ffee",
    "comment": "c0ffee with too much milk!"
  },
  { "rgb": "#654321",
    "oklch_hex": ["0x3fda7f0f7cad5a95","0x3fb14f391e693b33","0x404ffddc23d45503"],
    "oklch": "0.41401 0.06762 63.983"
  },
  { "rgb": "#f0f0f0"
  },
  { "rgb": "#000000",
    "oklch_hex": ["0x0000000000000000","0x0000000000000000","0x0000000000000000"],
    "oklch": "0.00000 0.00000 0.000"
  },
  { "comment": "nothing but comment!"
  },
  { "oklch_hex": ["0x3fe3333333333333","0x3fc5bcfd4bf0995b","0x406f400000000000"],
    "oklch": "0.60000 0.16983 250.000"
  }
];
  // ---- const that affect loading/saving files
  const KEYS = Object.freeze({ RGB: 'rgb', LCH_HEX: 'oklch_hex', OKLCH: 'oklch', COMMENT: 'comment' });

  root.ROWS = ROWS;
  root.defaultValues = defaultValues;
  root.KEYS = KEYS;
})(globalThis);
</script>

<script>
(function(root){
  const SoT_LCH = Array.from({length: ROWS}, () => null);
  function cssIntVar(name){ return parseInt(getComputedStyle(document.documentElement).getPropertyValue(name).trim(),10); }
  // Helpers: numeric rounding utilities
  function roundTo(x, n){ return Number(x.toFixed(n)); }
  function floorTo(x, n){
    const p = Math.pow(10, n);
    return Math.floor(x * p) / p;
  }
  function isInsideSrgb(L, C, h){
    const rgbLin = oklchToLinearSrgbRaw([
      Math.min(1, Math.max(0, L)),
      Math.max(0, C),
      normalizeHue(h)
    ]);
    return !rgbLin.some(v => v < -EPS || v > 1 + EPS);
  }
  function fmtLCH([L, C, h]){
    const Ld = cssIntVar("--L-precision");
    const Cd = cssIntVar("--C-precision");
    const Hd = cssIntVar("--H-precision");
  
    // 1) First, standard rounding to configured precision
    const Lr = roundTo(L, Ld);
    const Cr = roundTo(C, Cd);
    const Hr = roundTo(h, Hd);
  
    if (isInsideSrgb(Lr, Cr, Hr)){
      return `${Lr.toFixed(Ld)} ${Cr.toFixed(Cd)} ${Hr.toFixed(Hd)}`;
    }
  
    // 2) Try rounding down either L or C (choose the smaller adjustment)
    const Lf = floorTo(L, Ld);
    const Cf = floorTo(C, Cd);
  
    // magnitude of the “step down” from rounded to floored at this precision
    const stepL = Math.abs(Lr - Lf);
    const stepC = Math.abs(Cr - Cf);
  
    // Candidate A: lower L only
    const candA = { L: Lf, C: Cr, H: Hr, ok: isInsideSrgb(Lf, Cr, Hr) };
    // Candidate B: lower C only
    const candB = { L: Lr, C: Cf, H: Hr, ok: isInsideSrgb(Lr, Cf, Hr) };
  
    // Prefer the dimension with smaller step; if equal, prefer the one that passes; else any that passes
    const first = (stepL <= stepC) ? candA : candB;
    const second = (first === candA) ? candB : candA;
  
    if (first.ok){
      return `${first.L.toFixed(Ld)} ${first.C.toFixed(Cd)} ${first.H.toFixed(Hd)}`;
    }
    if (second.ok){
      return `${second.L.toFixed(Ld)} ${second.C.toFixed(Cd)} ${second.H.toFixed(Hd)}`;
    }
  
    // 3) Last resort: lower both L and C, return regardless
    const Lb = Lf, Cb = Cf, Hb = Hr;
    return `${Lb.toFixed(Ld)} ${Cb.toFixed(Cd)} ${Hb.toFixed(Hd)}`;
  }
  const rgbCol=document.getElementById('rgbcol'),
        strips=document.getElementById('strips'),
        oklchCol=document.getElementById('oklch'),
        lrgb=document.getElementById('lrgb'),
        deltaECol=document.getElementById('deltae'),
        commentCol=document.getElementById('comment');
  const clamp01=x=>Math.min(1,Math.max(0,x));
  const srgbToLin=u=>(u<=0.04045?u/12.92:Math.pow((u+0.055)/1.055,2.4));
  const linToSrgb=u=>(u<=0.0031308?12.92*u:1.055*Math.pow(u,1/2.4)-0.055);
  const cbrt=Math.cbrt||(x=>x<0?-Math.pow(-x,1/3):Math.pow(x,1/3));
  function hexToRgb(h){ if(!/^[0-9a-fA-F]{6}$/.test(h)) return null;
    return [parseInt(h.slice(0,2),16)/255, parseInt(h.slice(2,4),16)/255, parseInt(h.slice(4,6),16)/255]; }
  function rgbToHex(r,g,b){ const t=v=>{const n=Math.round(clamp01(v)*255); return n.toString(16).padStart(2,'0')}; return '#'+t(r)+t(g)+t(b); }
  function srgbToOklab([rs,gs,bs]){ const r=srgbToLin(rs), g=srgbToLin(gs), b=srgbToLin(bs);
    const l=0.4122214708*r+0.5363325363*g+0.0514459929*b;
    const m=0.2119034982*r+0.6806995451*g+0.1073969566*b;
    const s=0.0883024619*r+0.2817188376*g+0.6299787005*b;
    const l_=cbrt(l), m_=cbrt(m), s_=cbrt(s);
    return [0.2104542553*l_+0.7936177850*m_-0.0040720468*s_, 1.9779984951*l_-2.4285922050*m_+0.4505937099*s_, 0.0259040371*l_+0.7827717662*m_-0.8086757660*s_]; }
  function srgbToOklch(rgb){ const [L,a,b]=srgbToOklab(rgb); const C=Math.hypot(a,b); let h=Math.atan2(b,a)*180/Math.PI; if(h<0) h+=360; return [L,C,h]; }
  function oklchToSrgb([L,C,h]){ const hr=h*Math.PI/180, a=C*Math.cos(hr), b=C*Math.sin(hr);
    const l_=L+0.3963377774*a+0.2158037573*b, m_=L-0.1055613458*a-0.0638541728*b, s_=L-0.0894841775*a-1.2914855480*b;
    const l=l_**3, m=m_**3, s=s_**3;
    let r=+4.0767416621*l-3.3077115913*m+0.2309699292*s, g=-1.2684380046*l+2.6097574011*m-0.3413193965*s, b2=-0.0041960863*l-0.7034186147*m+1.7076147010*s;
    return [linToSrgb(r), linToSrgb(g), linToSrgb(b2)].map(clamp01); }
  // Linear sRGB (pre-gamma, no clamp) — for robust gamut checks
  function oklchToLinearSrgbRaw([L,C,h]){
    const hr=h*Math.PI/180, a=C*Math.cos(hr), b=C*Math.sin(hr);
    const l_=L+0.3963377774*a+0.2158037573*b, m_=L-0.1055613458*a-0.0638541728*b, s_=L-0.0894841775*a-1.2914855480*b;
    const l=l_**3, m=m_**3, s=s_**3;
    const r=+4.0767416621*l-3.3077115913*m+0.2309699292*s;
    const g=-1.2684380046*l+2.6097574011*m-0.3413193965*s;
    const b2=-0.0041960863*l-0.7034186147*m+1.7076147010*s;
    return [r,g,b2];
  }
  function oklchToOklab([L,C,h]){ const hr=h*Math.PI/180; return [L, C*Math.cos(hr), C*Math.sin(hr)]; }
  function deltaE([L1,a1,b1],[L2,a2,b2]){ return Math.hypot(L1-L2, a1-a2, b1-b2); }
  function parseOKLCHString(s){ if(!s) return null; s=String(s).trim().toLowerCase();
    if(s.startsWith('oklch')){ const m=s.match(/oklch\s*\(\s*([^)]+)\)/); if(!m) return null; s=m[1]; }
    s=s.replace(/\/.*$/,'').trim(); const p=s.split(/[\s,]+/); if(p.length<3) return null; const L=+p[0], C=+p[1], h=+p[2];
    return [L,C,h].every(Number.isFinite) ? [L,C,h] : null; }
  // --- Helpers for row operations ---
  function rowIndexOf(parent, child){
    return Array.prototype.indexOf.call(parent.children, child);
  }
  function isValidHex6(s){ return /^[0-9a-fA-F]{6}$/.test((s||'').trim()); }

  function handleToLCH(i){
    const rgbNode = (rgbCol.children[i].value||'').trim();
    if(!isValidHex6(rgbNode)) return;
    const lch = srgbToOklch(hexToRgb(rgbNode));
    SoT_LCH[i] = lch;
    const inp = oklchCol.children[i];
    if(inp && inp.tagName === 'INPUT'){ inp.value = fmtLCH(lch); }
    renderRow(i);
  }

  function handleToHEX(i){
    const s = (lrgb.children[i].textContent||'').trim();
    if(!isValidHex6(s)) return;
    const inp = rgbCol.children[i];
    if(inp && inp.tagName === 'INPUT'){ inp.value = s.toLowerCase(); }
    renderRow(i);
  }

  function handleLchHex2Oklch(i){
    const s = (lrgb.children[i].textContent||'').trim();
    if(!isValidHex6(s)) return;
    const lch = srgbToOklch(hexToRgb(s));
    SoT_LCH[i] = lch;
    const inp = oklchCol.children[i];
    if(inp && inp.tagName === 'INPUT'){ inp.value = fmtLCH(lch); }
    renderRow(i);
  }

  // --- Input filters ---
  const isHexChar = ch => /[0-9a-fA-F]/.test(ch);
  const filterHex = s => (s||'').replace(/[^0-9a-fA-F]/g,'').slice(0,6).toLowerCase();
  const filterLCHChars = s => (s||'').replace(/[^0-9. ]/g,''); // allow only digits, dot, space
  // trailing-dot helpers (DRY)
  const hasTrailingDotTokens = s => !!(s && /\b\d+\.(?=\s|$)/.test(s));
  const stripTrailingDots = s => (s||'').replace(/(\d+)\.(?=\s|$)/g, '$1');

  // gamut & clamp helpers
  const normalizeHue = h => ((h%360)+360)%360;
  const EPS = 1e-6;
  // --- Unified validation (single source of truth) ---
  
  function formatRgbLinMsg(rgbLin, lch){
    const [rr,gg,bb] = rgbLin;
    const [er,eg,eb] = rgbLin.map(v=>linToSrgb(v));
    // fetch precisions (+2 for display here)
    const Ld = cssIntVar("--L-precision") + 2;
    const Cd = cssIntVar("--C-precision") + 2;
    const Hd = cssIntVar("--H-precision") + 2;
	
    let lchPart = "";
    if (Array.isArray(lch) && lch.length === 3) {
      const [L,C,h] = lch;
      lchPart = `L=${L.toFixed(Ld)} C=${C.toFixed(Cd)} H=${h.toFixed(Hd)}; `;
    }
    return `${lchPart}(lin: r=${rr.toFixed(6)} g=${gg.toFixed(6)} b=${bb.toFixed(6)}; enc: r=${(er*255).toFixed(3)} g=${(eg*255).toFixed(3)} b=${(eb*255).toFixed(3)})`;
  }
  
  function validateLCHTriplet(lch){
    if(!Array.isArray(lch) || lch.length!==3) return { ok:false, reason:'parse' };
    const [L,C,h] = lch;
    const badL = !(Number.isFinite(L) && L>=0 && L<=1);
    const badC = !(Number.isFinite(C) && C>=0);
    const badH = !(Number.isFinite(h) && h>=0 && h<360);
    const rgbLin = oklchToLinearSrgbRaw([Math.min(1,Math.max(0,L)), Math.max(0,C), normalizeHue(h)]);
    const oog = rgbLin.some(v => v < -EPS || v > 1+EPS);
    return {
      ok: !(badL||badC||badH||oog),
      badL, badC, badH, oog,
      rgbLin
    };
  }

  function applyRowErrorState(i){
    const inp = oklchCol.children[i];
    if(!(inp && inp.tagName==='INPUT')) return;
    const val = (inp.value||'').trim();
    if(!val){ inp.classList.remove('err'); return; }
    if(hasTrailingDotTokens(val)){ inp.classList.add('err'); return; }
    const parsed = parseOKLCHString(val);
    if(!parsed){ inp.classList.add('err'); return; }
    const v = validateLCHTriplet(parsed);
    inp.classList.toggle('err', !v.ok);
  }

  function validateAndRenderRow(i){
    renderRow(i);
    applyRowErrorState(i);
  }

  // Clear the right patch & recompute visuals for a row (DRY)
  function clearRight(i){
    SoT_LCH[i] = null;
    renderRow(i);
  }
  const hexInputs=[];
  for(let i=0;i<ROWS;i++){ const inp=document.createElement('input'); inp.className='rowinput'; inp.maxLength=6; inp.autocapitalize='none'; inp.autocomplete='off'; inp.spellcheck=false; inp.value = ''; rgbCol.appendChild(inp); hexInputs.push(inp); }
  // Column 1: accept only hex chars, force lowercase on type/paste
  hexInputs.forEach((inp,i)=>{
    inp.addEventListener('beforeinput', (e)=>{
      const t = e.inputType;
      if (t === 'insertText') {
        if (!isHexChar(e.data)) { e.preventDefault(); return; }
        e.data = e.data.toLowerCase();
      } else if (t === 'insertFromPaste') {
        const txt = (e.clipboardData || window.clipboardData).getData('text');
        document.execCommand('insertText', false, filterHex(txt));
        e.preventDefault();
      }
    });
    inp.addEventListener('input', ()=>{
      const v = filterHex(inp.value);
      if (inp.value !== v) inp.value = v;
      renderRow(i);
    });
  });

  while(strips.children.length    < ROWS) strips.appendChild(document.createElement('div'));
  while(oklchCol.children.length  < ROWS) oklchCol.appendChild(document.createElement('input'));
  while(lrgb.children.length   < ROWS) lrgb.appendChild(document.createElement('div'));
  while(deltaECol.children.length < ROWS) deltaECol.appendChild(document.createElement('div'));
  while(commentCol.children.length < ROWS) commentCol.appendChild(document.createElement('input'));

  // Initialize OKLCH inputs once (empty)
  for(let i=0;i<ROWS;i++){
    const inp = oklchCol.children[i];
    if (inp && inp.tagName === 'INPUT') {
      inp.className = 'rowinput';
      inp.value = '';
    }
  }

  // Column 3: accept only digits, dot, and space
  oklchCol.addEventListener('beforeinput', (e)=>{
    if(!(e.target instanceof HTMLInputElement)) return;
    const t = e.inputType;
    if (t === 'insertText') {
      if (!/^[0-9. ]$/.test(e.data)) e.preventDefault();
    } else if (t === 'insertFromPaste') {
      const txt = (e.clipboardData || window.clipboardData).getData('text');
      document.execCommand('insertText', false, filterLCHChars(txt));
      e.preventDefault();
    }
  });
  
  // Comment column
  for (let i = 0; i < ROWS; i++) {
    const inp = commentCol.children[i];
    if (inp && inp.tagName === 'INPUT') {
      inp.className = 'rowinput';
    }
  }

  function renderRow(i){
  const rgbNode=(hexInputs[i].value||'').trim();
  const colorNode   = strips.children[i]; colorNode.className='chip';
  const lchNode     = oklchCol.children[i]; lchNode.className='rowinput';
  const lrgbNode = lrgb.children[i];    lrgbNode.className='rowtext';
  const deNode      = deltaECol.children[i];deNode.className='rowtext';

  // Update SoT (OKLCH) from Column 1 hex if valid; otherwise leave/null as seeded
  /* HEX edits do not mutate SoT */

  // Left patch = Column 1 hex (or default seed), right patch = SoT from Col 3
  const leftHex = (/^[0-9a-fA-F]{6}$/.test(rgbNode)) ? ('#'+rgbNode) : 'transparent';

  if(SoT_LCH[i]){
      const s4 = oklchToSrgb(SoT_LCH[i]);
      const rightHex = rgbToHex(...s4);
      lrgbNode.textContent = rightHex.replace(/^#/,''); 
      // Apply 50/50 split (no gap)
      colorNode.style.background = `linear-gradient(to right, ${leftHex} 0 50%, ${rightHex} 50% 100%)`;
    // compute ΔE inline instead of round-tripping
    const mode = (document.querySelector('input[name="deSrc"]:checked')||{}).value || 'col3';
    const rgb1 = /^[0-9a-fA-F]{6}$/.test(rgbNode) ? hexToRgb(rgbNode) : null;
    if(rgb1){
      let lab2;
      if (mode === 'col3') lab2 = oklchToOklab(SoT_LCH[i]);
      else {
        const qRgb = hexToRgb(lrgbNode.textContent);
        lab2 = qRgb ? srgbToOklab(qRgb) : null;
      }
      const dE = lab2 ? deltaE(srgbToOklab(rgb1), lab2) : NaN;
      deNode.textContent = Number.isFinite(dE) ? dE.toFixed(cssIntVar("--deltaE-precision")) : '';
    } else {
      deNode.textContent = '';
    }
  }
  else { 
    lrgbNode.textContent=''; 
    deNode.textContent=''; 
    const rightHex = 'transparent';
    colorNode.style.background = `linear-gradient(to right, ${leftHex} 0 50%, ${rightHex} 50% 100%)`;
  }
}
  function render(){ for(let i=0;i<ROWS;i++) renderRow(i); }
  oklchCol.addEventListener('input', (e)=>{
    if(!(e.target instanceof HTMLInputElement)) return;
    const i = Array.prototype.indexOf.call(oklchCol.children, e.target);
    if(i < 0) return;
    const rgbNode=(hexInputs[i].value||'').trim();
    const rgb = (/^[0-9a-fA-F]{6}$/.test(rgbNode)) ? hexToRgb(rgbNode) : null;
    const lrgbNode = lrgb.children[i];
    const deNode  = deltaECol.children[i];
    const errBox = document.getElementById('oklch-info');
    // special-case: numbers ending with a '.' are considered a parse error while typing
    if(hasTrailingDotTokens(e.target.value)){
      lrgbNode.textContent=''; deNode.textContent=''; SoT_LCH[i]=null;
      e.target.classList.add('err');
      if(errBox){ errBox.textContent='number must not end with a .'; errBox.classList.add('err'); }
      return;
    }
    const parsed = parseOKLCHString(e.target.value);
    if(!parsed){
      lrgbNode.textContent=''; deNode.textContent=''; SoT_LCH[i]=null; e.target.classList.add('err'); if(errBox){ errBox.textContent='Parse error'; errBox.classList.add('err'); }
      
      return;
    }
    SoT_LCH[i] = parsed; // keep user's rgbNode typing
    const [Lt,Ct,ht] = parsed;
    const outL = (Lt<0 || Lt>1);
    const outC = (Ct<0);
    const outH = (!Number.isFinite(ht) || ht < 0 || ht >= 360);
    const [Lc,Cc,hc] = parsed;
    const rtRgb = oklchToSrgb([Lc,Cc,hc]); lrgbNode.textContent = rgbToHex(...rtRgb).replace(/^#/,''); 
    const leftHex = (/^[0-9a-fA-F]{6}$/.test(rgbNode)) ? ('#'+rgbNode) : 'transparent';
    const rightHex = rgbToHex(...rtRgb);
    strips.children[i].style.background = `linear-gradient(to right, ${leftHex} 0 50%, ${rightHex} 50% 100%)`;
    const rgbLin = oklchToLinearSrgbRaw([Math.min(1,Math.max(0,Lt)), Math.max(0,Ct), normalizeHue(ht)]);
    const outOfGamut = rgbLin.some(v => v < -EPS || v > 1 + EPS);
    const hasErr = outL || outC || outH || outOfGamut;
    e.target.classList.toggle('err', hasErr);
    if(errBox){
      if(hasErr){
        const msgs=[];
        if(outL) msgs.push('L must be 0–1');
        if(outC) msgs.push('C must be ≥ 0');
        if(outH) msgs.push('H must be in [0, 360)');
        if(outOfGamut){ const [rr,gg,bb]=rgbLin; const [er,eg,eb]=rgbLin.map(v=>linToSrgb(v)); msgs.push(`out of sRGB ${formatRgbLinMsg(rgbLin, SoT_LCH[i])}`); }
        errBox.textContent = 'LCH: ' + msgs.join(' • ');
        errBox.classList.add('err');
      } else {
        errBox.textContent = '';
        errBox.classList.remove('err');
      }
    }
    if(!rgb){ deNode.textContent=''; return; }
    const mode = (document.querySelector('input[name="deSrc"]:checked')||{}).value || 'col3';
    let lab2; if (mode === 'col3') { lab2 = oklchToOklab([Lc,Cc,hc]); } else { const qRgb = hexToRgb(lrgbNode.textContent); lab2 = srgbToOklab(qRgb); }
    const dE = deltaE(srgbToOklab(rgb), lab2); deNode.textContent = dE.toFixed(cssIntVar("--deltaE-precision"));
  });

  
  // On blur: strip any trailing '.' from numeric tokens and re-parse (DRY)
  oklchCol.addEventListener('focusout', (e)=>{
    if(!(e.target instanceof HTMLInputElement)) return;
    const i = Array.prototype.indexOf.call(oklchCol.children, e.target);
    const val = e.target.value || '';
    if(hasTrailingDotTokens(val)){
      const cleaned = stripTrailingDots(val);
      if(cleaned !== val){
        e.target.value = cleaned;
        // trigger existing input pipeline
        e.target.dispatchEvent(new Event('input', {bubbles:true}));
      }
    }
    // If current value still does not parse as OKLCH, clear the right patch for this row.
    const parsed = parseOKLCHString(e.target.value || '');
    if(!parsed && val.trim() !== ''){
      clearRight(i);
    }
  });

  // Show guidance in header when focusing a row
  oklchCol.addEventListener('focusin', (e)=>{
    if(!(e.target instanceof HTMLInputElement)) return;
    const i = Array.prototype.indexOf.call(oklchCol.children, e.target);
    if(i < 0) return;
    const errBox = document.getElementById('oklch-info');
    if(!errBox) return;
    const val = e.target.value.trim();
    if(!val){
      // 2b. Row is empty
      errBox.textContent = 'Ranges — L: [0, 1], C ≥ 0, H: [0, 360)';
      errBox.classList.remove('err');
      return;
    }
    const parsed = parseOKLCHString(val);
    if(!parsed){
      errBox.textContent = 'Parse error';
      errBox.classList.add('err');
      return;
    }
    const [Lt,Ct,ht] = parsed;
    const outL = (Lt<0 || Lt>1);
    const outC = (Ct<0);
    const outH = (!Number.isFinite(ht) || ht < 0 || ht >= 360);
    const rgbLin = oklchToLinearSrgbRaw([Math.min(1,Math.max(0,Lt)), Math.max(0,Ct), normalizeHue(ht)]);
    const outOfGamut = rgbLin.some(v => v < -EPS || v > 1 + EPS);
    if(outL || outC || outH || outOfGamut){
      const msgs=[]; if(outL) msgs.push('L must be 0–1'); if(outC) msgs.push('C must be ≥ 0'); if(outH) msgs.push('H must be in [0, 360)'); if(outOfGamut){ const [rr,gg,bb]=rgbLin; const [er,eg,eb]=rgbLin.map(v=>linToSrgb(v)); msgs.push(`out of sRGB ${formatRgbLinMsg(rgbLin, SoT_LCH[i])}`); }
      errBox.textContent = 'LCH: ' + msgs.join(' • ');
      errBox.classList.add('err');  // 2c bold + bg
    } else {
      const [rr,gg,bb]=rgbLin;
      const [er,eg,eb]=rgbLin.map(v=>linToSrgb(v));
      errBox.textContent = `LCH: inside sRGB ${formatRgbLinMsg(rgbLin, SoT_LCH[i])}`;
      errBox.classList.remove('err');
    }
  });
  hexInputs.forEach((inp,i)=> inp.addEventListener('input', ()=> renderRow(i)));
  function recomputeAllDeltaE(){
    const mode = (document.querySelector('input[name=\"deSrc\"]:checked')||{}).value || 'col3';
    for(let i=0;i<ROWS;i++){
      const rgbNode = (rgbCol.children[i].value||'').trim(); const deNode = deltaECol.children[i];
      if(!(rgbNode && /^[0-9a-fA-F]{6}$/.test(rgbNode)) || !SoT_LCH[i]){ if(deNode) deNode.textContent=''; continue; }
      const rgb = hexToRgb(rgbNode);
      let lab2; if (mode === 'col3') { lab2 = oklchToOklab(SoT_LCH[i]); }
      else { const hexStr = lrgb.children[i] ? lrgb.children[i].textContent : ''; const qRgb = hexToRgb(hexStr); lab2 = qRgb ? srgbToOklab(qRgb) : null; }
      const dE = lab2 ? deltaE(srgbToOklab(rgb), lab2) : NaN; if(deNode) deNode.textContent = Number.isFinite(dE) ? dE.toFixed(cssIntVar("--deltaE-precision")) : '';
    }
  }
  document.querySelectorAll('input[name=\"deSrc\"]').forEach(r => r.addEventListener('change', recomputeAllDeltaE));
  render();
  // No startup conversion; we auto-load defaults below via the #load logic.
  
  // --- Button delegations ---
  document.getElementById('rgbtolch').addEventListener('click', (e)=>{ if(!(e.target instanceof HTMLButtonElement)) return; const i = rowIndexOf(e.currentTarget, e.target); if(i>=0){ handleToLCH(i); validateAndRenderRow(i); } });
  document.getElementById('lchtorgb').addEventListener('click', (e)=>{ if(!(e.target instanceof HTMLButtonElement)) return; const i = rowIndexOf(e.currentTarget, e.target); if(i>=0){ handleToHEX(i); validateAndRenderRow(i); } });
  document.getElementById('lrgbtolch').addEventListener('click', (e)=>{ if(!(e.target instanceof HTMLButtonElement)) return; const i = rowIndexOf(e.currentTarget, e.target); if(i>=0){ handleLchHex2Oklch(i); validateAndRenderRow(i); } });

  // --- Clear logic, reused by #clear and #load ---
  function doClearAll(silent=false){
    if(!silent && !confirm('Clear all rows to blank?')) return false;
    for(let i=0;i<ROWS;i++){
      SoT_LCH[i] = null;
      // col #1 inputs
      const inp = rgbCol.children[i];
      if(inp && inp.tagName === 'INPUT') inp.value = '';
      // col #3 OKLCH inputs
      const ok = oklchCol.children[i];
      if(ok && ok.tagName === 'INPUT'){ ok.value = ''; ok.classList.remove('err'); }
      // col #4 computed hex text
      const r4 = lrgb.children[i];
      if(r4) r4.textContent = '';
      // col #9 comments
      const cmt = commentCol.children[i];
      if(cmt && cmt.tagName === 'INPUT') cmt.value = '';
      // col #2 chips: reset to left-only (seed or transparent)
      if(strips.children[i]){
        strips.children[i].style.background = `linear-gradient(to right, transparent 0 50%, transparent 50% 100%)`;
      }
      // ΔE
      const de = deltaECol.children[i];
      if(de) de.textContent = '';
    }
    // info box
    const inf = document.getElementById('oklch-info');
    if(inf){ inf.textContent = 'Cleared all rows.'; inf.classList.remove('err'); }
    render(); // refresh visuals
    return true;
  }

  // --- Clear button delegates to doClearAll() with confirm ---
  (function(){
    const clearBtn = document.getElementById('clear');
    if(!clearBtn) return;
    clearBtn.addEventListener('click', ()=> doClearAll(false));
  })();

  // --- Load button: import JSON file and populate rows (DRY) ---
  (function(){
    const loadBtn = document.getElementById('load');
    if(!loadBtn) return;

    // helpers (mirror copy/save formats)
    function isHex6(s){ return /^[0-9a-fA-F]{6}$/.test((s||'').trim()); }
    function toHex6NoHash(s){
      if(typeof s !== 'string') return null;
      const m = s.trim().toLowerCase().match(/^#?([0-9a-f]{6})$/);
      return m ? m[1] : null;
    }
    function f64FromHexBE(s){
      // accept "0x" prefixed 16-byte hex or plain 16-byte hex
      if(typeof s !== 'string') return NaN;
      s = s.trim().toLowerCase().replace(/^0x/, '');
      if(!/^[0-9a-f]{16}$/.test(s)) return NaN;
      const buf = new ArrayBuffer(8);
      const dv = new DataView(buf);
      for(let i=0;i<8;i++){
        dv.setUint8(i, parseInt(s.slice(i*2, i*2+2), 16));
      }
      return dv.getFloat64(0, false); // big-endian
    }
    function parseSoTLCH(v){
      // accept [f64hex, f64hex, f64hex] or [number, number, number]
      if(!Array.isArray(v) || v.length!==3) return null;
      let L = v[0], C = v[1], h = v[2];
      if(typeof L === 'string') { L = f64FromHexBE(L); }
      if(typeof C === 'string') { C = f64FromHexBE(C); }
      if(typeof h === 'string') { h = f64FromHexBE(h); }
      if([L,C,h].every(Number.isFinite)) return [L,C,h];
      return null;
    }

    function setRowFromSoTLCH(row, lch){
      SoT_LCH[row] = lch;
      // update OKLCH text
      const inp = oklchCol.children[row];
      if(inp && inp.tagName === 'INPUT'){ inp.value = fmtLCH(lch); }
      // update right hex (#4) and color strip
      const hexRight = rgbToHex(...oklchToSrgb(lch));
      const lrgbNode = lrgb.children[row];
      if(lrgbNode) lrgbNode.textContent = hexRight.replace(/^#/,''); 
      const leftVal = (rgbCol.children[row] && rgbCol.children[row].value || '').trim();
      const leftHex = isHex6(leftVal) ? ('#'+leftVal) : 'transparent';
      if(strips.children[row]){
        strips.children[row].style.background = `linear-gradient(to right, ${leftHex} 0 50%, ${hexRight} 50% 100%)`;
      }
      validateAndRenderRow(row);
    }

    function setRowRgb(row, hex6){
      const inp = rgbCol.children[row];
      if(inp && inp.tagName === 'INPUT'){
        inp.value = hex6;
      }
      validateAndRenderRow(row);
    }

    // DRY: array-population helper used by both file load and startup
    function populateFromArray(data){
      const inf = document.getElementById('oklch-info');
      if(!Array.isArray(data)){
        if(inf){ inf.textContent = 'Load failed: JSON must be an array'; inf.classList.add('err'); }
        return;
      }
      doClearAll(true);
      let row = 0, filled = 0;
      for(const item of data){
        if(row >= ROWS) break;
        if(!item || typeof item !== 'object') continue;
        let someValidData = false;
        if(Object.prototype.hasOwnProperty.call(item, KEYS.RGB)){
          const h6 = toHex6NoHash(item.rgb);
          if(h6){ setRowRgb(row, h6); someValidData = true; }
        }
        let hadSoT = false;
        if(Object.prototype.hasOwnProperty.call(item, KEYS.LCH_HEX)){
          const lch = parseSoTLCH(item[KEYS.LCH_HEX]);
          if(lch){ setRowFromSoTLCH(row, lch); someValidData = true; hadSoT = true; }
        }
        if(!hadSoT && Object.prototype.hasOwnProperty.call(item, KEYS.OKLCH)){
          const parsed = parseOKLCHString(item[KEYS.OKLCH]);
          if(parsed){ setRowFromSoTLCH(row, parsed); someValidData = true; }
        }
        if (Object.prototype.hasOwnProperty.call(item, KEYS.COMMENT)) {
          const cv = (typeof item[KEYS.COMMENT] === 'string') ? item[KEYS.COMMENT].trim() : '';
          if (cv) {
            const cInput = commentCol.children[row];
            if (cInput && cInput.tagName === 'INPUT') { cInput.value = cv; someValidData = true; }
          }
        }
        if(someValidData){ row++; filled++; }
      }
      if(inf){
        if(filled>0){ inf.textContent = 'Loaded '+filled+' row(s) from JSON.'; inf.classList.remove('err'); }
        else{ inf.textContent = 'No valid rows found in JSON.'; inf.classList.add('err'); }
      }
    }

    loadBtn.addEventListener('click', ()=>{
      const fi = document.createElement('input');
      fi.type = 'file';
      fi.accept = '.json,application/json,text/json';
      fi.addEventListener('change', ()=>{
        const file = fi.files && fi.files[0];
        if(!file){ return; }
        const reader = new FileReader();
        reader.onload = ()=>{
          let data;
          try{
            data = JSON.parse(String(reader.result || ''));
          }catch{
            const inf = document.getElementById('oklch-info');
            if(inf){ inf.textContent = 'Load failed: invalid JSON'; inf.classList.add('err'); }
            return;
          }
          populateFromArray(data);
        };
        reader.readAsText(file);
      }, {once:true});
      fi.click();
    });

    // Auto-load defaults on startup
    if (Array.isArray(root.defaultValues)) {
      populateFromArray(root.defaultValues);
    }
  })();

  // --- Copy/Save buttons: dump rows to JSON (DRY) with IEEE-754 lossless bytes for SoT_LCH ---
  (function(){
    const copyBtn = document.getElementById('copy');
    const saveBtn = document.getElementById('save');
    if(!copyBtn && !saveBtn) return;

    function f64ToHexBE(n){
      const buf = new ArrayBuffer(8);
      const dv = new DataView(buf);
      dv.setFloat64(0, n, false); // big-endian
      let s = "0x";
      for(let i=0;i<8;i++){
        const b = dv.getUint8(i).toString(16).padStart(2,'0');
        s += b;
      }
      return s;
    }

    function isHex6(s){ return /^[0-9a-fA-F]{6}$/.test((s||'').trim()); }

    // --- shared JSON builder ---
    function buildJson(){
      const out = [];
      for(let i=0;i<ROWS;i++){
        const rowObj = {};
        // rgb from rgbcol.children[i] (input value), include as "#rrggbb" if valid
        const rgbIn = rgbCol.children[i];
        if(rgbIn && rgbIn.tagName === 'INPUT'){
          const v = (rgbIn.value||'').trim().toLowerCase();
          if(isHex6(v)){
            rowObj[KEYS.RGB] = "#" + v;
          }
        }

        // SoT_LCH as three IEEE-754 64-bit hex strings (big-endian)
        const lch = SoT_LCH[i];
        if(Array.isArray(lch) && lch.length===3 && lch.every(Number.isFinite)){
          rowObj[KEYS.LCH_HEX] = [ f64ToHexBE(lch[0]), f64ToHexBE(lch[1]), f64ToHexBE(lch[2]) ];
        }

        // oklch from oklchCol input if it parses as valid "L C H"
        const okIn = oklchCol.children[i];
        if(okIn && okIn.tagName === 'INPUT'){
          const raw = (okIn.value||'').trim();
          const parsed = parseOKLCHString(raw);
          if(parsed){
            rowObj[KEYS.OKLCH] = raw;
          }
        }

        // comment from commentCol input (include only when non-empty)
        const cIn = commentCol.children[i];
        if (cIn && cIn.tagName === 'INPUT') {
          const cv = (cIn.value || '').trim();
          if (cv) {
            rowObj[KEYS.COMMENT] = cv;
          }
        }

        // Include row only if at least one key is present
        if(Object.keys(rowObj).length > 0){
          out.push(rowObj);
        }
      }

      let json = JSON.stringify(out, null, 2);
      
      // compact SoT_LCH arrays
      json = json.replace(
        /(\[\s*\n\s*"0x[0-9a-f]+".*?\n\s*\])/gis,
        m => m.replace(/\s*\n\s*/g, "")
      );
      
      // move opening brace up
      json = json.replace(/\{\n\s*/g, "{ ");
      return {json, count: out.length};
    }

    // --- copy handler ---
    copyBtn?.addEventListener('click', async () => {
      const {json, count} = buildJson();
      try{
        if(navigator.clipboard && window.isSecureContext){
          await navigator.clipboard.writeText(json);
        }else{
          const ta = document.createElement('textarea');
          ta.value = json;
          ta.style.position = 'fixed';
          ta.style.opacity = '0';
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        }
        const inf = document.getElementById('oklch-info');
        if(inf){ inf.textContent = 'Copied JSON ('+count+' rows) to clipboard.'; inf.classList.remove('err'); }
      }catch{
        const inf = document.getElementById('oklch-info');
        if(inf){ inf.textContent = 'Copy failed'; inf.classList.add('err'); }
      }
    });

    // --- save handler ---
    saveBtn?.addEventListener('click', () => {
      const {json, count} = buildJson();
      const blob = new Blob([json], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "oklch.json";
      a.click();
      URL.revokeObjectURL(url);
      const inf = document.getElementById('oklch-info');
      if(inf){ inf.textContent = 'Saved JSON ('+count+' rows) to file.'; inf.classList.remove('err'); }
    });
  })();
})(globalThis);

</script>

<script>
// Dynamically add →LCH / ←HEX buttons per row based on ROWS
(function(root){
  const toL = document.getElementById('rgbtolch');
  const toH = document.getElementById('lchtorgb');
  const toLCH = document.getElementById('lrgbtolch');
  if(!toL || !toH || !toLCH || typeof ROWS === 'undefined') return;
  for(let i=0;i<ROWS;i++){
    const bL = document.createElement('button');
    bL.className = 'convert-button';
    bL.type = 'button';
    bL.textContent = '\u2192LCH'; // →LCH
    toL.appendChild(bL);

    const bMid = document.createElement('button');
    bMid.className = 'convert-button';
    bMid.type = 'button';
    bMid.textContent = '\u2190LCH'; // ←LCH
    toLCH.appendChild(bMid);

    const bH = document.createElement('button');
    bH.className = 'convert-button';
    bH.type = 'button';
    bH.textContent = '\u2190HEX'; // ←HEX
    toH.appendChild(bH);
  }
})(globalThis);
</script>

<script>
/* Theme switcher IIFE (no storage): 
   - Startup follows system theme
   - Clicking toggles light/dark for this session only
   - If user never toggled, updates live when OS theme changes
*/
(function () {
  const btn  = document.getElementById('theme');
  if (!btn) return;
  const root = document.documentElement;

  const mq = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
  let userOverride = false; // becomes true once the user clicks the toggle

  function apply(theme) {
    root.dataset.theme = theme;
    const isDark = theme === 'dark';
    btn.setAttribute('aria-pressed', String(isDark));
    btn.title = isDark ? 'Switch to light theme' : 'Switch to dark theme';
  }

  // 1) initial: follow system
  const systemDark = mq && mq.matches;
  apply(systemDark ? 'dark' : 'light');

  // 2) toggle: set explicit theme for this session (no persistence)
  btn.addEventListener('click', () => {
    const next = (root.dataset.theme === 'dark') ? 'light' : 'dark';
    userOverride = true;
    apply(next);
  });

  // 3) react to future OS changes only if user hasn't overridden
  if (mq && mq.addEventListener) {
    mq.addEventListener('change', e => {
      if (userOverride) return;
      apply(e.matches ? 'dark' : 'light');
    });
  } else if (mq && mq.addListener) { // Safari fallback
    mq.addListener(e => {
      if (userOverride) return;
      apply(e.matches ? 'dark' : 'light');
    });
  }
})();
</script>

</body>
</html>
